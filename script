# Carregando bibliotecas necessárias
library(sf)
library(dplyr)
library(terra)
library(tidyverse)
library(knitr)
library(scales)

# Configuração de área de trabalho
setwd('D:/PAN - DELTA/ANALISES/priorizacao')
getwd()

#' Configuração inicial do ambiente de trabalho
#' Aqui deve ser solocado todos os diretórios de entrada e saida
#' @param base_dir Diretório base para o projeto
#' @return Lista com caminhos dos diretórios
setup_environment <- function(base_dir) {
  dirs <- list(
    priorizacao = file.path(base_dir, "ANALISES/priorizacao"),
    pan = file.path(base_dir, "ANALISES/dados_analise_r/territorio"),
    spp = file.path(base_dir, "ANALISES/dados_analise_r/spp"),
    otto = file.path(base_dir, "ANALISES/dados_analise_r/otto"),
    uc = file.path(base_dir, "ANALISES/dados_analise_r/uc"),
    mineracao = file.path(base_dir, "ANALISES/dados_analise_r/mineracao"),
    energia = file.path(base_dir, "ANALISES/dados_analise_r/energia"),
    app = file.path(base_dir, "ANALISES/dados_analise_r/app")
    #mapbiomas = file.path(base_dir, "ANALISES/dados_analise_r/mapbiomas")
    #fogo = file.path(base_dir, "ANALISES/dados_analise_r/fogo")
  )
  
  # Verificar existência dos diretórios
  lapply(dirs, function(d) {
    if (!dir.exists(d)) stop(paste("Diretório não encontrado:", d))
  })
  
  return(dirs)
}

#' Carregar e processar território PAN
#' @param pan_dir Diretório contendo shapefile do PAN
#' @return Objeto sf do território PAN
load_pan_territory <- function(pan_dir) {
  pan_file <- list.files(path = pan_dir, pattern = "\\.shp$", full.names = TRUE)[1]
  if (is.na(pan_file)) stop("Shapefile do PAN não encontrado")
  
  pan <- st_read(pan_file, quiet = TRUE) %>%
    st_transform(crs = 4674)
  
  return(pan)
}

#' Processar dados de espécies a partir de CSVs
#' @param spp_dir Diretório com dados das espécies
#' @param base_shp_name Nome do arquivo shapefile base
process_species_from_csv <- function(spp_dir, base_shp_name) {
  base_shp <- st_read(file.path(spp_dir, base_shp_name), quiet = TRUE)%>%
    mutate(across(where(is.character), ~ iconv(., from = "", to = "UTF-8")))
  csv_files <- list.files(path = spp_dir, pattern = "*.csv", full.names = TRUE)
  
  for(csv_file in csv_files) {
    species_data <- read_csv(csv_file)
    species_list <- species_data[[1]]
    output_name <- tools::file_path_sans_ext(basename(csv_file))
    
    filtered_shp <- base_shp %>%
      filter(specie_fb %in% species_list)
    
    cat("Arquivo:", output_name, "\n")
    cat("Espécies no CSV:", length(species_list), "\n")
    cat("Espécies encontradas:", nrow(filtered_shp), "\n")
    print("Lista de espécies:")
    print(species_list)
    
    if(nrow(filtered_shp) > 0) {
      st_write(filtered_shp, 
               file.path(spp_dir, paste0(output_name, ".shp")), 
               append = FALSE)
    }
  }
}

#' Criar raster padrão
#' @param pan_sf Objeto sf do território PAN
#' @param resolution Resolução desejada do raster
#' @return Objeto raster padrão
create_standard_raster <- function(pan_sf, resolution = c(0.005, 0.005)) {
  r_padrao <- rast()
  terra::crs(r_padrao) <- "EPSG:4674"
  ext(r_padrao) <- ext(pan_sf)
  res(r_padrao) <- resolution
  values(r_padrao) <- 1
  
  return(r_padrao)
}

#' Baixar e processar raster do MapBiomas
#' @param mapbiomas_url URL do arquivo MapBiomas
#' @param pan_sf Objeto sf do território PAN
#' @return Raster processado
download_mapbiomas <- function(mapbiomas_url, pan_sf) {
  # Criar diretório temporário para download
  temp_file <- file.path(tempdir(), "mapbiomas_temp.tif")
  
  tryCatch({
    # Download do arquivo
    download.file(mapbiomas_url, temp_file, mode = "wb")
    
    # Configurar opções do GDAL para otimizar memória
    terra::gdalCache(2048)
    
    # Abrir o raster com configurações otimizadas
    raster_mapbiomas <- rast(temp_file)
    
    # Recortar para extensão do PAN
    raster_mapbiomas <- terra::crop(raster_mapbiomas, terra::vect(pan_sf))
    raster_mapbiomas <- terra::mask(raster_mapbiomas, terra::vect(pan_sf))
    
    # Ajustar CRS se necessário
    if (!crs(raster_mapbiomas) == "EPSG:4674") {
      raster_mapbiomas <- terra::project(raster_mapbiomas, "EPSG:4674", 
                                         method = "near", 
                                         threads = TRUE)
    }
    
    return(list(raster = raster_mapbiomas, temp_file = temp_file))
    
  }, error = function(e) {
    stop("Erro ao processar MapBiomas: ", e$message)
  })
}

#' Baixar e processar raster do MapBiomas Frequencia de FOGO
#' @param mapbiomas_fogo_url URL do arquivo MapBiomas
#' @param pan_sf Objeto sf do território PAN
#' @return Raster processado
download_mapbiomas_fogo <- function(mapbiomas_fogo_url, pan_sf) {
  # Criar diretório temporário para download
  temp_file_fogo <- file.path(tempdir(), "mapbiomas_fogo_temp.tif")
  
  tryCatch({
    # Download do arquivo
    download.file(mapbiomas_fogo_url, temp_file_fogo, mode = "wb")
    
    # Configurar opções do GDAL para otimizar memória
    terra::gdalCache(2048)
    
    # Abrir o raster com configurações otimizadas
    raster_mapbiomas_fogo <- rast(temp_file_fogo)
    
    # Recortar para extensão do PAN
    raster_mapbiomas_fogo <- terra::crop(raster_mapbiomas_fogo, terra::vect(pan_sf))
    raster_mapbiomas_fogo <- terra::mask(raster_mapbiomas_fogo, terra::vect(pan_sf))
    
    # Ajustar CRS se necessário
    if (!crs(raster_mapbiomas_fogo) == "EPSG:4674") {
      raster_mapbiomas_fogo <- terra::project(raster_mapbiomas_fogo, "EPSG:4674", 
                                         method = "near", 
                                         threads = TRUE)
    }
    
    return(list(raster_fogo = raster_mapbiomas_fogo, temp_file_fogo = temp_file_fogo))
    
  }, error = function(e) {
    stop("Erro ao processar MapBiomas: ", e$message)
  })
}

#' Baixar e processar raster do MapBiomas Qualidade de Pasto
#' @param mapbiomas_pasto_url URL do arquivo MapBiomas
#' @param pan_sf Objeto sf do território PAN
#' @return Raster processado
download_mapbiomas_pasto <- function(mapbiomas_pasto_url, pan_sf) {
  # Criar diretório temporário para download
  temp_file_pasto <- file.path(tempdir(), "mapbiomas_pasto_temp.tif")
  
  tryCatch({
    # Download do arquivo
    download.file(mapbiomas_pasto_url, temp_file_pasto, mode = "wb")
    
    # Configurar opções do GDAL para otimizar memória
    terra::gdalCache(2048)
    
    # Abrir o raster com configurações otimizadas
    raster_mapbiomas_pasto <- rast(temp_file_pasto)
    
    # Recortar para extensão do PAN
    raster_mapbiomas_pasto <- terra::crop(raster_mapbiomas_pasto, terra::vect(pan_sf))
    raster_mapbiomas_pasto <- terra::mask(raster_mapbiomas_pasto, terra::vect(pan_sf))
    
    # Ajustar CRS se necessário
    if (!crs(raster_mapbiomas_pasto) == "EPSG:4674") {
      raster_mapbiomas_pasto <- terra::project(raster_mapbiomas_pasto, "EPSG:4674", 
                                              method = "near", 
                                              threads = TRUE)
    }
    
    return(list(raster_pasto = raster_mapbiomas_pasto, temp_file_pasto = temp_file_pasto))
    
  }, error = function(e) {
    stop("Erro ao processar MapBiomas: ", e$message)
  })
}

#' Baixar e processar raster do MapBiomas Idade da Vegetação Secundária
#' @param mapbiomas_veg_sec_url URL do arquivo MapBiomas de idade da vegetação secundária
#' @param pan_sf Objeto sf do território PAN
#' @return Raster processado
download_mapbiomas_veg_sec <- function(mapbiomas_veg_sec_url, pan_sf) {
  # Criar diretório temporário para download
  temp_file_veg_sec <- file.path(tempdir(), "mapbiomas_veg_sec_temp.tif")
  
  tryCatch({
    # Download do arquivo
    download.file(mapbiomas_veg_sec_url, temp_file_veg_sec, mode = "wb")
    
    # Configurar opções do GDAL para otimizar memória
    terra::gdalCache(2048)
    
    # Abrir o raster com configurações otimizadas
    raster_mapbiomas_veg_sec <- rast(temp_file_veg_sec)
    
    # Recortar para extensão do PAN
    raster_mapbiomas_veg_sec <- terra::crop(raster_mapbiomas_veg_sec, terra::vect(pan_sf))
    raster_mapbiomas_veg_sec <- terra::mask(raster_mapbiomas_veg_sec, terra::vect(pan_sf))
    
    # Ajustar CRS se necessário
    if (!crs(raster_mapbiomas_veg_sec) == "EPSG:4674") {
      raster_mapbiomas_veg_sec <- terra::project(raster_mapbiomas_veg_sec, "EPSG:4674", 
                                                 method = "near", 
                                                 threads = TRUE)
    }
    
    return(list(raster_veg_sec = raster_mapbiomas_veg_sec, temp_file_veg_sec = temp_file_veg_sec))
    
  }, error = function(e) {
    stop("Erro ao processar MapBiomas Vegetação Secundária: ", e$message)
  })
}

#' Processar dados de espécies com análise MapBiomas (espécies)
#' @param spp_file Caminho do arquivo shapefile das espécies
#' @param mapbiomas_url URL do arquivo MapBiomas
#' @param output_dir Diretório de saída
#' @param r_padrao Raster padrão
#' @param pan_sf Objeto sf do território PAN
process_species <- function(spp_file, raster_mapbiomas, output_dir, r_padrao, pan_sf) {
  # Ler shapefile das espécies
  spp <- st_read(spp_file, quiet = TRUE)
  
  # Criar diretório para saída
  pasta_saida <- file.path(output_dir, "spp_alvo")
  if (!dir.exists(pasta_saida)) dir.create(pasta_saida)
  
  # Criar hulls convexos para cada espécie
  hulls <- spp %>%
    group_by(specie_fb) %>%
    summarise(geometry = st_combine(geometry)) %>%
    st_convex_hull()
  
  # Salvar hulls em GeoPackage
  st_write(hulls, file.path(output_dir, "todas_spp_alvo.gpkg"), delete_dsn = TRUE)
  
  # Converter PAN para vetor terra
  pan_vetor <- terra::vect(pan_sf)
  
  # Recortar raster MapBiomas pela área do PAN
  raster_mapbiomas_pan <- terra::crop(raster_mapbiomas, pan_vetor)
  raster_mapbiomas_pan <- terra::mask(raster_mapbiomas_pan, pan_vetor)
  
  # Reclassificar MapBiomas (formações florestais e savânicas)
  valores_interesse <- c(3,4)
  rcl <- cbind(valores_interesse, rep(1, length(valores_interesse)))
  raster_extraido <- terra::classify(raster_mapbiomas_pan, rcl = rcl, others = 0)
  
  # Processar cada espécie
  for (i in 1:nrow(hulls)) {
    especie <- hulls[i, ]
    if (st_is_empty(especie$geometry)) {
      warning(sprintf("Geometria vazia para %s", especie$specie_fb))
      next
    }
    
    try({
      # Processar MapBiomas para a espécie
      especie_vetor <- terra::vect(especie)
      
      # Recortar área da espécie no MapBiomas do PAN
      raster_recortado <- terra::crop(raster_extraido, especie_vetor, snap = "out")
      raster_recortado <- terra::mask(raster_recortado, especie_vetor)
      
      # Criar raster com toda área do PAN preenchido com 0
      raster_pan <- terra::rasterize(pan_vetor, r_padrao, field = 0)
      
      if (!is.null(raster_recortado) && !all(is.na(values(raster_recortado)))) {
        # Reamostrar raster recortado
        raster_padronizado <- terra::resample(raster_recortado, r_padrao, 
                                              method = "near",
                                              threads = TRUE)
        
        # Substituir valores no raster do PAN
        raster_final <- terra::cover(raster_padronizado, raster_pan)
        
        output_mapbiomas <- file.path(pasta_saida, 
                                      paste0(make.names(especie$specie_fb), ".tif"))
        
        # Escrever com compressão
        terra::writeRaster(raster_final, output_mapbiomas, 
                           overwrite = TRUE,
                           gdal = c("COMPRESS=LZW", "PREDICTOR=2"))
      }
      
      # Limpar memória
      rm(raster_recortado, raster_padronizado, raster_pan, raster_final)
      gc()
    })
  }
}

#' Processar dados de espécies beneficiadas (DD e NT)
#' @param benefited_spp_file Caminho do arquivo shapefile das espécies beneficiadas
#' @param mapbiomas_url URL do arquivo MapBiomas
#' @param output_dir Diretório de saída
#' @param r_padrao Raster padrão
#' @param pan_sf Objeto sf do território PAN
process_benefited_species <- function(benefited_spp_file, raster_mapbiomas, output_dir, r_padrao, pan_sf) {
  benefited_spp <- st_read(benefited_spp_file, quiet = TRUE)
  
  # Criar diretório para saída
  pasta_saida <- file.path(output_dir, "spp_beneficiadas")
  if (!dir.exists(pasta_saida)) dir.create(pasta_saida)
  
  # Criar hulls convexos para cada espécie beneficiada
  hulls <- benefited_spp %>%
    group_by(specie_fb) %>%
    summarise(geometry = st_combine(geometry)) %>%
    st_convex_hull()
  
  # Salvar hulls em GeoPackage
  st_write(hulls, file.path(output_dir, "todas_spp_beneficiadas.gpkg"), delete_dsn = TRUE)
  
  # Reclassificar MapBiomas
  valores_interesse <- c(3,4)
  rcl <- cbind(valores_interesse, rep(1, length(valores_interesse)))
  raster_extraido <- terra::classify(raster_mapbiomas, rcl = rcl, others = 0)
  
  # Processar cada espécie beneficiada
  for (i in 1:nrow(hulls)) {
    especie <- hulls[i, ]
    if (st_is_empty(especie$geometry)) {
      warning(sprintf("Geometria vazia para %s", especie$specie_fb))
      next
    }
    
    try({
      # Processar MapBiomas para a espécie
      especie_vetor <- terra::vect(especie)
      
      # Recortar área da espécie
      raster_recortado <- terra::crop(raster_extraido, especie_vetor, snap = "out")
      raster_recortado <- terra::mask(raster_recortado, especie_vetor)
      
      if (!is.null(raster_recortado) && !all(is.na(values(raster_recortado)))) {
        # Reamostrar
        raster_padronizado <- terra::resample(raster_recortado, r_padrao,
                                              method = "near",
                                              threads = TRUE)
        
        output_mapbiomas <- file.path(pasta_saida,
                                      paste0(make.names(especie$specie_fb), "_beneficiada.tif"))
        
        # Escrever com compressão
        terra::writeRaster(raster_padronizado, output_mapbiomas,
                           overwrite = TRUE,
                           gdal = c("COMPRESS=LZW", "PREDICTOR=2"))
      }
      
      # Limpar memória
      rm(raster_recortado, raster_padronizado)
      gc()
    })
  }
}

#' Criar raster de quadrículas - VERSÃO SIMPLIFICADA
#' @param r_padrao Objeto raster padrão
#' @param output_dir Diretório de saída para salvar o resultado
#' @param write_vector Booleano para indicar se deve salvar o vetor de quadrículas também (TRUE/FALSE)
#' @return Objeto raster de quadrículas
create_grid_raster <- function(r_padrao, output_dir, write_vector = TRUE) {
  
  cat("Usando versão simplificada de create_grid_raster\n")
  
  # Simplesmente criar um raster com IDs únicos baseado no raster padrão
  tryCatch({
    # Obter número de células
    n_cells <- ncell(r_padrao)
    
    if (n_cells > 0) {
      # Criar cópia do raster padrão
      grid_raster <- r_padrao
      
      # Atribuir IDs únicos às células
      values(grid_raster) <- 1:n_cells
      
      # Salvar o raster
      terra::writeRaster(grid_raster,
                         file.path(output_dir, "grid_quadriculas.tif"),
                         overwrite = TRUE,
                         gdal = c("COMPRESS=LZW", "PREDICTOR=2"))
      
      cat("Raster de quadrículas criado com", n_cells, "células\n")
      
      # Se solicitado, criar também o vetor (opcional)
      if (write_vector) {
        cat("AVISO: Criação de grid vetorial desabilitada na versão simplificada\n")
      }
      
      return(grid_raster)
      
    } else {
      stop("Raster padrão não tem células válidas")
    }
    
  }, error = function(e) {
    stop(paste("Erro ao criar grid simplificado:", e$message))
  })
}

#' Processar dados das Ottobacias
#' @param otto_dir Diretório com dados das Ottobacias
#' @param r_padrao Raster padrão
#' @param output_dir Diretório de saída
#' @param pan_sf Objeto sf do território PAN
process_otto <- function(otto_dir, r_padrao, output_dir, pan_sf) {
  otto_file <- list.files(path = otto_dir, pattern = "\\.shp$", full.names = TRUE)[1]
  if (is.na(otto_file)) stop("Arquivo Ottobacias não encontrado")
  
  otto_shp <- st_read(otto_file, quiet = TRUE) %>%
    st_transform(crs = 4674)
  
  if (!"wts_cd_pfa" %in% names(otto_shp)) {
    stop("Campo 'wts_cd_pfa' não encontrado no shapefile das Ottobacias")
  }
  
  otto_vect <- terra::vect(otto_shp)
  otto_raster <- terra::rasterize(otto_vect, r_padrao, field = "wts_cd_pfa") %>%
    terra::mask(terra::vect(pan_sf))
  
  otto_raster[is.na(otto_raster)] <- 0
  
  terra::writeRaster(otto_raster, 
                     file.path(output_dir, "otto.tif"),
                     overwrite = TRUE)
}

#' Processar dados das Unidades de Conservação
#' @param uc_dir Diretório com dados das UCs
#' @param r_padrao Raster padrão
#' @param output_dir Diretório de saída
#' @param pan_sf Objeto sf do território PAN
process_uc <- function(uc_dir, r_padrao, output_dir, pan_sf) {
  uc_file <- list.files(path = uc_dir, pattern = "\\.shp$", full.names = TRUE)[1]
  if (is.na(uc_file)) stop("Arquivo UCs não encontrado")
  
  uc_shp <- st_read(uc_file, quiet = TRUE) %>%
    st_transform(crs = 4674) %>%
    filter(categoria != "Área de Proteção Ambiental")  # Filtra as APAs
  
  # Verifica se existem UCs de Proteção Integral
  if (nrow(uc_shp) == 0) {
    warning("Nenhuma UC de Proteção Integral encontrada no arquivo")
    return(NULL)
  }
  
  uc_vect <- terra::vect(uc_shp)
  uc_raster <- terra::rasterize(uc_vect, r_padrao, field = 1)
  
  uc_raster[!is.na(uc_raster)] <- 0  # Áreas dentro das UCs
  uc_raster[is.na(uc_raster)] <- 1   # Áreas fora das UCs
  
  terra::writeRaster(uc_raster,
                     file.path(output_dir, "ucs_sem_apa.tif"),
                     overwrite = TRUE)
}

#' Processar dados de Mineração (vetor de pressão)
#' @param mineracao_dir Diretório com dados de mineração
#' @param r_padrao Raster padrão
#' @param output_dir Diretório de saída
#' @param pan_sf Objeto sf do território PAN
process_mineracao <- function(mineracao_dir, r_padrao, output_dir, pan_sf) {
  mineracao_file <- list.files(path = mineracao_dir, pattern = "\\.shp$", full.names = TRUE)[1]
  if (is.na(mineracao_file)) stop("Arquivo mineração não encontrado")
  
  mineracao_shp <- st_read(mineracao_file, quiet = TRUE) %>%
    st_transform(crs = 4674)
  
  mineracao_vect <- terra::vect(mineracao_shp)
  mineracao_raster <- terra::rasterize(mineracao_vect, r_padrao, field = "NUMERO") %>%
    terra::mask(terra::vect(pan_sf))
  
  mineracao_raster[is.na(mineracao_raster)] <- 0
  #mineracao_raster[mineracao_raster == 0] <- NA
  mineracao_raster <- terra::mask( mineracao_raster, terra::vect(pan_sf))
  
  terra::writeRaster(mineracao_raster,
                     file.path(output_dir, "mineracao.tif"),
                     overwrite = TRUE)
}

#' Processar dados de Energia (vetor de pressão)
#' @param energia_dir Diretório com dados de energia
#' @param r_padrao Raster padrão
#' @param output_dir Diretório de saída
#' @param pan_sf Objeto sf do território PAN
process_energia <- function(energia_dir, r_padrao, output_dir, pan_sf) {
  energia_file <- list.files(path = energia_dir, pattern = "\\.shp$", full.names = TRUE)[1]
  if (is.na(energia_file)) stop("Arquivo mineração não encontrado")
  
  energia_shp <- st_read(energia_file, quiet = TRUE) %>%
    st_transform(crs = 4674)
  
  energia_vect <- terra::vect(energia_shp)
  energia_raster <- terra::rasterize(energia_vect, r_padrao) %>% #, field = "id"
    terra::mask(terra::vect(pan_sf))
  
  energia_raster[is.na(energia_raster)] <- 0
  #mineracao_raster[mineracao_raster == 0] <- NA
  energia_raster <- terra::mask( energia_raster, terra::vect(pan_sf))
  
  terra::writeRaster(energia_raster,
                     file.path(output_dir, "energia.tif"),
                     overwrite = TRUE)
}

#' Processar dados do MapBiomas (vetor de pressão)
#' @param mapbiomas_url URL dos dados do MapBiomas
#' @param r_padrao Raster padrão
#' @param output_dir Diretório de saída
#' @param pan_sf Objeto sf do território PAN
process_mapbiomas_agricultura <- function(raster_mapbiomas, r_padrao, output_dir, pan_sf) {
  # Para uso e ocupação do solo
  valores_interesse <- c(15, 21, 24, 25, 39, 41, 48)  # Classes de interesse
  rcl <- cbind(valores_interesse, rep(1, length(valores_interesse)))
  raster_extraido <- classify(raster_mapbiomas, rcl = rcl, others = 0)
  
  raster_padronizado <- terra::resample(raster_extraido, r_padrao, method = "near") %>%
    terra::mask(terra::vect(pan_sf))
  
  # Salvar raster
  terra::writeRaster(raster_padronizado,
                     file.path(output_dir, "agro.tif"),
                     overwrite = TRUE)
}

#' Processar dados de Fogo (vetor de pressão)
#' @param raster_mapbiomas_fogo Raster de dados de fogo
#' @param temp_file_fogo Caminho do arquivo temporário
#' @param r_padrao Raster padrão
#' @param output_dir Diretório de saída
#' @param pan_sf Objeto sf do território PAN
process_fogo <- function(raster_mapbiomas_fogo, temp_file_fogo, r_padrao, output_dir, pan_sf) { 
  # Reamostrar para o raster padrão
  raster_redimensionado_fogo <- terra::resample(raster_mapbiomas_fogo, r_padrao, method = "near")
  
  # Garantir que o CRS do vetor é o mesmo do raster
  if (terra::crs(raster_redimensionado_fogo) != terra::crs(pan_sf)) {
    pan_sf <- terra::project(terra::vect(pan_sf), terra::crs(raster_redimensionado_fogo))
  }
  
  # Aplicar máscara
  raster_redimensionado_fogo <- terra::mask(raster_redimensionado_fogo, pan_sf)
  
  # Limpar arquivo temporário
  unlink(temp_file_fogo)
  
  # Salvar raster final
  terra::writeRaster(raster_redimensionado_fogo,
                     file.path(output_dir, "fogo.tif"),
                     overwrite = TRUE)
}

#' Processar dados de Qualidade de Pasto (vetor de pressão)
#' Essa função, unifica as classes de interesse em uma unica classe.
#' @param raster_mapbiomas_pasto Raster de dados de Pasto
#' @param temp_file_pasto Caminho do arquivo temporário
#' @param r_padrao Raster padrão
#' @param output_dir Diretório de saída
#' @param pan_sf Objeto sf do território PAN
#process_pasto <- function(raster_mapbiomas_pasto, temp_file_pasto, r_padrao, output_dir, pan_sf) { 
  # Extrair apenas os valores específicos (2 e 3)
  valores_interesse <- c(2, 3)  # Classes de interesse para pasto
  rcl <- cbind(valores_interesse, rep(1, length(valores_interesse)))
  raster_extraido <- terra::classify(raster_mapbiomas_pasto, rcl = rcl, others = 0)
  
  # Reamostrar para o raster padrão
  raster_redimensionado_pasto <- terra::resample(raster_extraido, r_padrao, method = "near")
  
  # Garantir que o CRS do vetor é o mesmo do raster
  if (terra::crs(raster_redimensionado_pasto) != terra::crs(pan_sf)) {
    pan_sf <- terra::project(terra::vect(pan_sf), terra::crs(raster_redimensionado_pasto))
  }
  
  # Aplicar máscara
  raster_redimensionado_pasto <- terra::mask(raster_redimensionado_pasto, pan_sf)
  
  # Limpar arquivo temporário
  unlink(temp_file_pasto)
  
  # Salvar raster final
  terra::writeRaster(raster_redimensionado_pasto,
                     file.path(output_dir, "pasto_q.tif"),
                     overwrite = TRUE)
}

#' Processar dados de Qualidade de Pasto (vetor de pressão)
#' Essa função utiliza as duas classes de interesse na mesma imagem, não padroniza tudo como 1.
#' @param raster_mapbiomas_pasto Raster de dados de Pasto
#' @param temp_file_pasto Caminho do arquivo temporário
#' @param r_padrao Raster padrão
#' @param output_dir Diretório de saída
#' @param pan_sf Objeto sf do território PAN
process_pasto <- function(raster_mapbiomas_pasto, temp_file_pasto, r_padrao, output_dir, pan_sf) { 
  # Extrair apenas os valores específicos (2 e 3), mantendo-os diferenciados
  valores_interesse <- c(2, 3)  # Classes de interesse para pasto
  
  # Criar função para manter apenas os valores de interesse
  raster_extraido <- terra::ifel(raster_mapbiomas_pasto %in% valores_interesse, 
                                 raster_mapbiomas_pasto, 
                                 0)
  
  # Reamostrar para o raster padrão
  raster_redimensionado_pasto <- terra::resample(raster_extraido, r_padrao, method = "near")
  
  # Garantir que o CRS do vetor é o mesmo do raster
  if (terra::crs(raster_redimensionado_pasto) != terra::crs(pan_sf)) {
    pan_sf <- terra::project(terra::vect(pan_sf), terra::crs(raster_redimensionado_pasto))
  }
  
  # Aplicar máscara
  raster_redimensionado_pasto <- terra::mask(raster_redimensionado_pasto, pan_sf)
  
  # Limpar arquivo temporário
  unlink(temp_file_pasto)
  
  # Salvar raster final
  terra::writeRaster(raster_redimensionado_pasto,
                     file.path(output_dir, "pasto_q.tif"),
                     overwrite = TRUE)
}

#' Processar dados MapBiomas (Idade da Vegetação Secundária) 
#' @param raster_mapbiomas_veg_sec Raster de dados de idade da vegetação secundária
#' @param temp_file_veg_sec Caminho do arquivo temporário
#' @param r_padrao Raster padrão
#' @param output_dir Diretório de saída
#' @param pan_sf Objeto sf do território PAN
process_veg_sec <- function(raster_mapbiomas_veg_sec, temp_file_veg_sec, r_padrao, output_dir, pan_sf) { 
  # Reamostrar para o raster padrão
  raster_redimensionado_veg_sec <- terra::resample(raster_mapbiomas_veg_sec, r_padrao, method = "near")
  
  # Garantir que o CRS do vetor é o mesmo do raster
  if (terra::crs(raster_redimensionado_veg_sec) != terra::crs(pan_sf)) {
    pan_sf <- terra::project(terra::vect(pan_sf), terra::crs(raster_redimensionado_veg_sec))
  }
  
  # Aplicar máscara
  raster_redimensionado_veg_sec <- terra::mask(raster_redimensionado_veg_sec, pan_sf)
  
  # Limpar arquivo temporário
  unlink(temp_file_veg_sec)
  
  # Salvar raster final
  terra::writeRaster(raster_redimensionado_veg_sec,
                     file.path(output_dir, "veg_secundaria.tif"),
                     overwrite = TRUE)
}

#' Processar dados do MapBiomas (Vegetação)
#' @param mapbiomas_url URL dos dados do MapBiomas
#' @param r_padrao Raster padrão
#' @param output_dir Diretório de saída
#' @param pan_sf Objeto sf do território PAN
process_mapbiomas_floresta <- function(raster_mapbiomas, r_padrao, output_dir, pan_sf) {
  # Para uso e ocupação do solo
  valores_interesse <- c(3)  # Classes de interesse
  rcl <- cbind(valores_interesse, rep(1, length(valores_interesse)))
  raster_extraido <- classify(raster_mapbiomas, rcl = rcl, others = 0)
  
  raster_padronizado <- terra::resample(raster_extraido, r_padrao, method = "near") %>%
    terra::mask(terra::vect(pan_sf))
  
  # Salvar raster
  terra::writeRaster(raster_padronizado,
                     file.path(output_dir, "floresta.tif"),
                     overwrite = TRUE)
}

#' Processar dados do MapBiomas (Vegetação)
#' @param mapbiomas_url URL dos dados do MapBiomas
#' @param r_padrao Raster padrão
#' @param output_dir Diretório de saída
#' @param pan_sf Objeto sf do território PAN
process_mapbiomas_savana <- function(raster_mapbiomas, r_padrao, output_dir, pan_sf) {
  # Para uso e ocupação do solo
  valores_interesse <- c(4)  # Classes de interesse
  rcl <- cbind(valores_interesse, rep(1, length(valores_interesse)))
  raster_extraido <- classify(raster_mapbiomas, rcl = rcl, others = 0)
  
  raster_padronizado <- terra::resample(raster_extraido, r_padrao, method = "near") %>%
    terra::mask(terra::vect(pan_sf))
  
  # Salvar raster
  terra::writeRaster(raster_padronizado,
                     file.path(output_dir, "savana.tif"),
                     overwrite = TRUE)
}

#' Processar dados de APP (APP p/restauração)
#' @param app_dir Diretório com dados de app
#' @param r_padrao Raster padrão
#' @param output_dir Diretório de saída
#' @param pan_sf Objeto sf do território PAN
process_app <- function(app_dir, r_padrao, output_dir, pan_sf) {
  # Encontrar arquivos shapefile de APP
  app_files <- list.files(
    path = app_dir, 
    pattern = "*_APP_USO.*\\.shp$", 
    full.names = TRUE, 
    recursive = TRUE
  )
  
  # Validar existência de arquivos
  if (length(app_files) == 0) {
    warning("Nenhum arquivo shapefile de APP encontrado")
    return(NULL)
  }
  
  # Função para filtrar áreas antropizadas
  filter_antropized_areas <- function(shp) {
    # Colunas para verificar uso do solo
    uso_cols <- grep(
      "CLASSE|CLAS|USO|DESC|TIPO|CLASS|COD", 
      names(shp), 
      ignore.case = TRUE, 
      value = TRUE
    )
    
    for (col in uso_cols) {
      # Filtrar áreas antropizadas
      antropized <- shp %>% 
        filter(grepl(
          "antropi|antrop|uso|agri|past|urban|cultiv", 
          as.character(!!sym(col)), 
          ignore.case = TRUE
        ))
      
      if (nrow(antropized) > 0) return(antropized)
    }
    
    return(NULL)
  }
  
  # Processar shapefiles de APP
  app_filtered <- lapply(app_files, function(file) {
    tryCatch({
      # Ler shapefile e transformar CRS
      shp <- st_read(file, quiet = TRUE, options = "ENCODING=UTF-8") %>%
        st_transform(crs = 4674)
      
      # Filtrar áreas antropizadas
      filter_antropized_areas(shp)
    }, error = function(e) {
      warning(paste("Erro ao processar", basename(file), ":", e$message))
      return(NULL)
    })
  })
  
  # Remover NULLs e verificar se há áreas filtradas
  app_filtered <- Filter(Negate(is.null), app_filtered)
  
  if (length(app_filtered) == 0) {
    warning("Nenhuma área antropizada encontrada")
    return(NULL)
  }
  
  # Unificar shapefiles filtrados
  tryCatch({
    # Combinar shapefiles
    app_unificado <- do.call(rbind, app_filtered) %>%
      st_transform(crs = st_crs(pan_sf))
    
    # Salvar shapefile unificado
    st_write(
      app_unificado, 
      file.path(output_dir, "app_areas_antropizadas_unificado.shp"),
      delete_dsn = TRUE,
      quiet = TRUE
    )
    
    # Preparar para rasterização
    app_vect <- terra::vect(app_unificado)
    pan_vect <- terra::vect(pan_sf)
    
    # Rasterizar e mascarar dentro do PAN
    app_raster <- terra::rasterize(app_vect, r_padrao, field = 1) %>%
      terra::mask(terra::vect(pan_sf))
    
    # Substituir NA por 0
    app_raster[is.na(app_raster)] <- 0
    
    # Mascarar novamente para garantir apenas dentro do PAN
    app_raster <- terra::mask(app_raster, terra::vect(pan_sf))
    
    # Salvar raster
    terra::writeRaster(
      app_raster,
      file.path(output_dir, "app_antropizada.tif"),
      overwrite = TRUE,
      gdal = c("COMPRESS=LZW", "PREDICTOR=2")
    )
    
    return(app_raster)
  }, error = function(e) {
    warning(paste("Erro no processamento final:", e$message))
    return(NULL)
  })
}

#' Gerar rasters baseados em ottobacias com ocorrências de espécies (spp em otto)
#' @param spp_file Caminho do arquivo shapefile das espécies
#' @param otto_file Caminho do arquivo shapefile das ottobacias
#' @param output_dir Diretório de saída
#' @param r_padrao Raster padrão
#' @param pan_sf Objeto sf do território PAN
#' @param tipo_spp Tipo de espécie ("alvo" ou "beneficiada")
process_species_by_otto <- function(spp_file, otto_file, output_dir, r_padrao, pan_sf, tipo_spp = "alvo") {
  # Configurações iniciais
  pasta_saida <- file.path(output_dir, paste0("spp_", tipo_spp, "_ottobacias"))
  if (!dir.exists(pasta_saida)) dir.create(pasta_saida, recursive = TRUE)
  
  # Arquivo de log para acompanhamento
  log_file <- file.path(output_dir, paste0("log_processamento_", tipo_spp, ".txt"))
  cat(paste("Iniciando processamento:", Sys.time(), "\n"), file=log_file)
  
  # Carregar dados apenas uma vez
  message("Carregando dados de espécies...")
  tryCatch({
    spp <- st_read(spp_file, quiet = TRUE) %>%
      st_transform(crs = 4674) %>%
      st_make_valid()
    
    message("Carregando dados de ottobacias...")
    otto_shp <- st_read(otto_file, quiet = TRUE) %>%
      st_transform(crs = 4674) %>%
      st_make_valid()
    
    # Obter lista de espécies
    especies_unicas <- unique(spp$specie_fb)
    message(paste("Processando", length(especies_unicas), "espécies..."))
    cat(paste("Total de espécies a processar:", length(especies_unicas), "\n"), file=log_file, append=TRUE)
    
    # Preparar PAN uma vez
    pan_valid <- st_make_valid(pan_sf)
    
    # Processar cada espécie INDIVIDUALMENTE em uma função separada
    for (i in seq_along(especies_unicas)) {
      esp <- especies_unicas[i]
      
      # Criar uma função interna para isolar completamente o processamento de cada espécie
      process_single_species <- function() {
        message(paste("Processando espécie", i, "de", length(especies_unicas), ":", esp))
        cat(paste("Processando espécie", i, "de", length(especies_unicas), ":", esp, "\n"), 
            file=log_file, append=TRUE)
        
        # Filtrar pontos da espécie atual
        pontos_esp <- spp %>% 
          filter(specie_fb == esp) %>%
          st_make_valid()
        
        # Verificar se há pontos para esta espécie
        if (nrow(pontos_esp) == 0) {
          msg <- sprintf("Nenhum ponto encontrado para a espécie %s", esp)
          warning(msg)
          cat(paste("  AVISO:", msg, "\n"), file=log_file, append=TRUE)
          return(FALSE)
        }
        
        # Encontrar ottobacias que contêm pontos desta espécie
        ottobacias_com_pontos <- st_join(
          otto_shp,
          pontos_esp,
          join = st_contains
        ) %>%
          filter(!is.na(specie_fb)) %>%
          distinct(wts_cd_pfa)
        
        # Verificar se há ottobacias com pontos desta espécie
        if (nrow(ottobacias_com_pontos) == 0) {
          msg <- sprintf("Nenhuma ottobacia contém pontos da espécie %s", esp)
          warning(msg)
          cat(paste("  AVISO:", msg, "\n"), file=log_file, append=TRUE)
          return(FALSE)
        }
        
        # Selecionar ottobacias com pontos da espécie
        otto_subset <- otto_shp %>%
          filter(wts_cd_pfa %in% ottobacias_com_pontos$wts_cd_pfa)
        
        # Limitar apenas à área do PAN
        otto_subset <- st_intersection(otto_subset, pan_valid)
        
        # Verificar se há ottobacias dentro do PAN
        if (nrow(otto_subset) == 0) {
          msg <- sprintf("Nenhuma ottobacia com pontos da espécie %s está dentro da área do PAN", esp)
          warning(msg)
          cat(paste("  AVISO:", msg, "\n"), file=log_file, append=TRUE)
          return(FALSE)
        }
        
        # Rasterizar as ottobacias selecionadas
        otto_vect <- terra::vect(otto_subset)
        
        # Criar raster com toda área do PAN preenchido com 0
        raster_pan <- terra::rasterize(terra::vect(pan_valid), r_padrao, field = 0)
        
        # Rasterizar ottobacias com valor 1
        otto_raster <- terra::rasterize(otto_vect, r_padrao, field = 1)
        
        # Substituir valores no raster do PAN
        raster_final <- terra::cover(otto_raster, raster_pan)
        
        # Escrever raster final
        output_file <- file.path(pasta_saida, paste0(make.names(esp), "_otto.tif"))
        terra::writeRaster(raster_final, output_file, 
                           overwrite = TRUE,
                           gdal = c("COMPRESS=LZW", "PREDICTOR=2"))
        
        message(paste("Raster criado:", output_file))
        cat(paste("  SUCESSO: Raster criado para", esp, "\n"), file=log_file, append=TRUE)
        
        # Limpar memória explicitamente
        rm(raster_final, otto_raster, raster_pan, otto_vect, otto_subset)
        gc(full = TRUE)
        
        return(TRUE)
      }
      
      # Executar a função de processamento individual com tratamento de erro
      result <- tryCatch({
        process_single_species()
      }, error = function(e) {
        msg <- sprintf("ERRO ao processar espécie %s: %s", esp, e$message)
        warning(msg)
        cat(paste("  ERRO:", msg, "\n"), file=log_file, append=TRUE)
        return(FALSE)
      })
      
      # Limpar o ambiente após cada espécie, independente do resultado
      rm(process_single_species)
      gc(full = TRUE)
    }
    
    # Tentar criar o shapefile final
    cat("Criando shapefile final...\n", file=log_file, append=TRUE)
    tryCatch({
      # Usar um método mais seguro para criar ottobacias_todas_especies
      especies_por_otto <- data.frame()
      
      for (esp in especies_unicas) {
        pontos_esp <- spp %>% filter(specie_fb == esp)
        
        # Encontrar ottobacias para esta espécie
        ottos_esp <- st_join(
          otto_shp,
          pontos_esp,
          join = st_contains
        ) %>%
          filter(!is.na(specie_fb)) %>%
          distinct(wts_cd_pfa)
        
        if (nrow(ottos_esp) > 0) {
          df_temp <- data.frame(
            wts_cd_pfa = ottos_esp$wts_cd_pfa,
            especie = esp,
            stringsAsFactors = FALSE
          )
          especies_por_otto <- rbind(especies_por_otto, df_temp)
        }
      }
      
      # Agregar dados por ottobacia
      if (nrow(especies_por_otto) > 0) {
        resumo_ottobacias <- aggregate(
          especie ~ wts_cd_pfa, 
          data = especies_por_otto, 
          FUN = function(x) length(unique(x))
        )
        names(resumo_ottobacias)[2] <- "n_especies"
        
        # Juntar com geometria
        ottobacias_final <- otto_shp %>%
          filter(wts_cd_pfa %in% resumo_ottobacias$wts_cd_pfa) %>%
          left_join(resumo_ottobacias, by = "wts_cd_pfa")
        
        # Salvar
        st_write(ottobacias_final, 
                 file.path(output_dir, paste0("ottobacias_", tipo_spp, ".gpkg")), 
                 delete_dsn = TRUE)
        
        cat("Shapefile final criado com sucesso!\n", file=log_file, append=TRUE)
      } else {
        cat("AVISO: Nenhuma ottobacia com espécies encontrada para criar o shapefile final.\n", 
            file=log_file, append=TRUE)
      }
    }, error = function(e) {
      msg <- sprintf("Erro ao criar shapefile final: %s", e$message)
      warning(msg)
      cat(paste("ERRO:", msg, "\n"), file=log_file, append=TRUE)
    })
    
  }, error = function(e) {
    msg <- sprintf("Erro crítico no processamento: %s", e$message)
    warning(msg)
    cat(paste("ERRO CRÍTICO:", msg, "\n"), file=log_file, append=TRUE)
    return(FALSE)
  })
  
  cat(paste("Processamento concluído:", Sys.time(), "\n"), file=log_file, append=TRUE)
  message("Processamento por ottobacias concluído!")
  return(TRUE)
}

#' Função principal que executa todo o pipeline
#' @param base_dir Diretório base do projeto
main <- function(base_dir) {
  # Configurar ambiente
  dirs <- setup_environment(base_dir)
  
  # Carregar território PAN
  pan_sf <- load_pan_territory(dirs$pan)
  
  # Criar raster padrão
  r_padrao <- create_standard_raster(pan_sf)
  
  # URLs do MapBiomas (atualizar para URL válida)
  mapbiomas_url <- "https://storage.googleapis.com/mapbiomas-public/initiatives/brasil/collection_10/lulc/coverage/brazil_coverage_2024.tif"
  mapbiomas_fogo_url <- "https://storage.googleapis.com/mapbiomas-public/initiatives/brasil/collection_9/fire col4/accumulated_burned_coverage_v1/mapbiomas_fire_col4_br_accumulated_burned_coverage_1985_2024.tif"
  mapbiomas_pasto_url <- "https://storage.googleapis.com/mapbiomas-public/initiatives/brasil/collection_9/pasture-1/mapbiomas_collection90_pasture_vigor_v1/mapbiomas_collection90_pasture_vigor_v1-vigor_2023.tif"
  mapbiomas_veg_sec_url <- "https://storage.googleapis.com/mapbiomas-public/initiatives/brasil/collection_9/lulc-1/sec-veg-1/mapbiomas_collection90_secondary_vegetation_age_v1/mapbiomas_collection90_secondary_vegetation_age_v1-secondary_vegetation_age_2023.tif"
  
  # Baixar e processar MapBiomas uma vez
  mapbiomas_data <- download_mapbiomas(mapbiomas_url, pan_sf)
  mapbiomas_fogo_data <- download_mapbiomas_fogo(mapbiomas_fogo_url, pan_sf)
  mapbiomas_pasto_data <- download_mapbiomas_pasto(mapbiomas_pasto_url, pan_sf)
  mapbiomas_veg_sec_data <- download_mapbiomas_veg_sec(mapbiomas_veg_sec_url, pan_sf)
  
  
  # Processar espécies usando EOO
  process_species_from_csv(dirs$spp, "SPP_LISTA_2022_SIRGAS2000_CNCFLORA.shp")
  process_species(file.path(dirs$spp, "spp_alvo.shp"),mapbiomas_data$raster, dirs$priorizacao,r_padrao,pan_sf)
  process_benefited_species(file.path(dirs$spp, "spp_beneficiada.shp"),mapbiomas_data$raster,dirs$priorizacao,r_padrao,pan_sf)
  
  # NOVA FUNCIONALIDADE: Processar espécies por ottobacias
  #process_species_by_otto(
  #  file.path(dirs$spp, "spp_alvo.shp"),
  #  list.files(path = dirs$otto, pattern = "\\.shp$", full.names = TRUE)[1],
  #  dirs$priorizacao,
  #  r_padrao,
  #  pan_sf,
  #  "alvo"
  #)
  
  #process_species_by_otto(
  #  file.path(dirs$spp, "spp_beneficiada.shp"),
  #  list.files(path = dirs$otto, pattern = "\\.shp$", full.names = TRUE)[1],
  #  dirs$priorizacao,
  #  r_padrao,
  #  pan_sf,
  #  "beneficiada"
  #)
  
  # Processar cada conjunto de dados
  
  process_fogo(
    mapbiomas_fogo_data$raster_fogo, 
    mapbiomas_fogo_data$temp_file_fogo,
    r_padrao, dirs$priorizacao, pan_sf
  )
  
  process_pasto(
    mapbiomas_pasto_data$raster_pasto,
    mapbiomas_pasto_data$temp_file_pasto,
    r_padrao, dirs$priorizacao, pan_sf
  )
  
  process_mapbiomas_agricultura(
    mapbiomas_data$raster, 
    r_padrao, dirs$priorizacao, pan_sf
  )
  
  
  process_mapbiomas_floresta(
    mapbiomas_data$raster, 
    r_padrao, dirs$priorizacao, pan_sf
  )
  
  process_mapbiomas_savana(
    mapbiomas_data$raster, 
    r_padrao, dirs$priorizacao, pan_sf
  )
  
  process_veg_sec(
    mapbiomas_veg_sec_data$raster_veg_sec,
    mapbiomas_veg_sec_data$temp_file_veg_sec,
    r_padrao, dirs$priorizacao, pan_sf
  )
  
  process_app(dirs$app, r_padrao, dirs$priorizacao, pan_sf)
  process_uc(dirs$uc, r_padrao, dirs$priorizacao, pan_sf)
  process_mineracao(dirs$mineracao, r_padrao, dirs$priorizacao, pan_sf)
  process_energia(dirs$energia, r_padrao, dirs$priorizacao, pan_sf)
  process_otto(dirs$otto, r_padrao, dirs$priorizacao, pan_sf)
  grid_raster <- create_grid_raster(r_padrao, dirs$priorizacao, write_vector = TRUE)
  
  # Limpar arquivo temporário
  unlink(mapbiomas_data$temp_file)
  unlink(mapbiomas_fogo_data$temp_file_fogo)
  unlink(mapbiomas_pasto_data$temp_file_pasto)
  unlink(mapbiomas_veg_sec_data$temp_file_veg_sec)
  
  cat("Processamento completo!\n")
}

# Executar o pipeline
base_dir <- "D:/PAN - DELTA"
main(base_dir)

